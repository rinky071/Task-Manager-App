from asyncio import tasks
import datetime
from fastapi import APIRouter, FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Counter, List, Optional
import json
import os

app = FastAPI()
router = APIRouter()
origins = [
    "http://localhost:3000",
    "http://127.0.0.1:3000"
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

DB_FILE = "tasks.json"

# Task model
class Task(BaseModel):
    id: Optional[int] = None  # ID is optional, it will be generated by the backend
    user: str
    title: str
    type: str
    assigned_by: str
    assigned_to: str
    language: str
    date: str
    description: str
    priority: str
    due_date: str
    status: str
    completed: bool

# Load tasks from the JSON file
def load_tasks():
    if not os.path.exists(DB_FILE):
        return []
    with open(DB_FILE, "r") as f:
        return json.load(f)

# Save tasks to the JSON file
def save_tasks(tasks):
    with open(DB_FILE, "w") as f:
        json.dump(tasks, f, indent=4)




# Add a new task
@app.post("/tasks/")
def add_task(task: Task):
    tasks = load_tasks()

    # Ensure the max_id calculation only considers tasks with a valid 'id'
    # Default max_id to 0 if no tasks are found
    max_id = max((t["id"] for t in tasks if t["id"] is not None), default=0)
    task.id = max_id + 1  # Assign the new unique ID
    tasks.append(task.dict())
    save_tasks(tasks)

    # Return all tasks (including the new one) after adding the task
    return {"message": "Task added successfully"}




@app.get("/tasks")
def get_tasks():
    tasks = load_tasks()
    return tasks  

# Get all tasks for a id
@app.get("/tasks/{task_id}")
def get_task_by_id(task_id: int):
    tasks = load_tasks()

    # Ensure that task_id is being compared properly
    task = next((task for task in tasks if task.get("id") == task_id), None)
    
    if task is None:
        raise HTTPException(status_code=404, detail="Task not found")
    
    return task








# Delete a task by its ID
@app.delete("/tasks/{task_id}")
def delete_task(task_id: int):
    tasks = load_tasks()
    tasks = [t for t in tasks if t["id"] != task_id]
    save_tasks(tasks)
    return {"message": "Task deleted"}

# Update a task by its ID
@app.put("/tasks/{task_id}")
def update_task(task_id: int, updated_task: Task):
    tasks = load_tasks()
    for i, task in enumerate(tasks):
        if task["id"] == task_id:
            tasks[i] = updated_task.dict()
            save_tasks(tasks)
            return {"message": "Task updated successfully"}
    raise HTTPException(status_code=404, detail="Task not found")

# User management
USER_DB = "users.json"

class User(BaseModel):
    email: str
    password: str

# Read users from the users JSON file
def read_users() -> List[User]:
    if not os.path.exists(USER_DB):
        return []
    with open(USER_DB, "r") as f:
        return [User(**user) for user in json.load(f)]

# Write users to the users JSON file
def write_users(users: List[User]):
    with open(USER_DB, "w") as f:
        json.dump([user.dict() for user in users], f, indent=4)

# Register a new user
@app.post("/register")
def register_user(user: User):
    users = read_users()
    if any(u.email == user.email for u in users):
        raise HTTPException(status_code=400, detail="User already exists")
    users.append(user)
    write_users(users)
    return {"message": "User registered successfully"}

# Login a user
@app.post("/login")
def login_user(user: User):
    users = read_users()
    if any(u.email == user.email and u.password == user.password for u in users):
        return {"message": "Login successful"}
    raise HTTPException(status_code=401, detail="Invalid credentials")


# dashboard page

@router.get("/dashboard")
def get_dashboard_data():
    tasks: List[Task] = load_tasks()
    today = datetime.date.today()

    employees = set(task['assigned_to'] for task in tasks if task.get('assigned_to'))
    all_tasks = len(tasks)
    overdue = sum(1 for task in tasks if task.get('due_date') and task['due_date'] < str(today) and not task['completed'])
    no_deadline = sum(1 for task in tasks if not task.get('due_date'))
    due_today = sum(1 for task in tasks if task.get('due_date') == str(today))
    notifications = overdue + due_today
    pending = sum(1 for task in tasks if task.get('status') == 'Pending')
    in_progress = sum(1 for task in tasks if task.get('status') == 'In Progress')
    completed = sum(1 for task in tasks if task.get('completed'))

    return {
        "Employee": len(employees),
        "All Tasks": all_tasks,
        "Overdue": overdue,
        "No Deadline": no_deadline,
        "Due Today": due_today,
        "Notifications": notifications,
        "Pending": pending,
        "In Progress": in_progress,
        "Completed": completed,
    }